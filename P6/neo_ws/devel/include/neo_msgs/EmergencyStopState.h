// Generated by gencpp from file neo_msgs/EmergencyStopState.msg
// DO NOT EDIT!


#ifndef NEO_MSGS_MESSAGE_EMERGENCYSTOPSTATE_H
#define NEO_MSGS_MESSAGE_EMERGENCYSTOPSTATE_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace neo_msgs
{
template <class ContainerAllocator>
struct EmergencyStopState_
{
  typedef EmergencyStopState_<ContainerAllocator> Type;

  EmergencyStopState_()
    : emergency_button_stop(false)
    , scanner_stop(false)
    , emergency_state(0)  {
    }
  EmergencyStopState_(const ContainerAllocator& _alloc)
    : emergency_button_stop(false)
    , scanner_stop(false)
    , emergency_state(0)  {
  (void)_alloc;
    }



   typedef uint8_t _emergency_button_stop_type;
  _emergency_button_stop_type emergency_button_stop;

   typedef uint8_t _scanner_stop_type;
  _scanner_stop_type scanner_stop;

   typedef int16_t _emergency_state_type;
  _emergency_state_type emergency_state;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(EMFREE)
  #undef EMFREE
#endif
#if defined(_WIN32) && defined(EMSTOP)
  #undef EMSTOP
#endif
#if defined(_WIN32) && defined(EMCONFIRMED)
  #undef EMCONFIRMED
#endif

  enum {
    EMFREE = 0,
    EMSTOP = 1,
    EMCONFIRMED = 2,
  };


  typedef boost::shared_ptr< ::neo_msgs::EmergencyStopState_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::neo_msgs::EmergencyStopState_<ContainerAllocator> const> ConstPtr;

}; // struct EmergencyStopState_

typedef ::neo_msgs::EmergencyStopState_<std::allocator<void> > EmergencyStopState;

typedef boost::shared_ptr< ::neo_msgs::EmergencyStopState > EmergencyStopStatePtr;
typedef boost::shared_ptr< ::neo_msgs::EmergencyStopState const> EmergencyStopStateConstPtr;

// constants requiring out of line definition

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::neo_msgs::EmergencyStopState_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::neo_msgs::EmergencyStopState_<ContainerAllocator1> & lhs, const ::neo_msgs::EmergencyStopState_<ContainerAllocator2> & rhs)
{
  return lhs.emergency_button_stop == rhs.emergency_button_stop &&
    lhs.scanner_stop == rhs.scanner_stop &&
    lhs.emergency_state == rhs.emergency_state;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::neo_msgs::EmergencyStopState_<ContainerAllocator1> & lhs, const ::neo_msgs::EmergencyStopState_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace neo_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::neo_msgs::EmergencyStopState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::neo_msgs::EmergencyStopState_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::neo_msgs::EmergencyStopState_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "d857d7312ffc16f75239036504e493e9";
  }

  static const char* value(const ::neo_msgs::EmergencyStopState_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xd857d7312ffc16f7ULL;
  static const uint64_t static_value2 = 0x5239036504e493e9ULL;
};

template<class ContainerAllocator>
struct DataType< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "neo_msgs/EmergencyStopState";
  }

  static const char* value(const ::neo_msgs::EmergencyStopState_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# This message holds the emergency stop (EMStop) status of the robot. It detects wether an EMStop is caused by the safety laserscanner or the emergency stop buttons. Moreover, it gives signalizes wether the EMStop was confirmed (after Button press stop) and the system is free again.\n"
"\n"
"# Possible EMStop States\n"
"int16 EMFREE = 0 		# system operatign normal\n"
"int16 EMSTOP = 1 		# emergency stop is active (Button pressed; obstacle in safety field of scanner)\n"
"int16 EMCONFIRMED = 2 	# emergency stop was confirmed system is reinitializing and going back to normal\n"
"\n"
"bool emergency_button_stop	# true = emergency stop signal is issued by button pressed\n"
"bool scanner_stop			# true = emergency stop signal is issued by scanner\n"
"int16 emergency_state		# state (including confimation by key-switch), values see above\n"
"\n"
;
  }

  static const char* value(const ::neo_msgs::EmergencyStopState_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.emergency_button_stop);
      stream.next(m.scanner_stop);
      stream.next(m.emergency_state);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct EmergencyStopState_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::neo_msgs::EmergencyStopState_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::neo_msgs::EmergencyStopState_<ContainerAllocator>& v)
  {
    s << indent << "emergency_button_stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.emergency_button_stop);
    s << indent << "scanner_stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.scanner_stop);
    s << indent << "emergency_state: ";
    Printer<int16_t>::stream(s, indent + "  ", v.emergency_state);
  }
};

} // namespace message_operations
} // namespace ros

#endif // NEO_MSGS_MESSAGE_EMERGENCYSTOPSTATE_H
